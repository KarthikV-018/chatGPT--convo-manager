Software Requirements Specification (SRS)
ChatGPT Conversation Management System

1. Introduction
   1.1 Purpose
   The purpose of this SRS document is to define the comprehensive requirements for the ChatGPT
   Conversation Management System. This system will facilitate intelligent conversation organization,
   advanced AI interaction capabilities, and comprehensive dialogue management for users engaging with
   ChatGPT while enabling administrators, developers, and researchers to handle conversation analytics,
   model training, and user experience optimization. The system provides robust tools for conversation
   threading, context management, prompt engineering, and AI response analysis while ensuring seamless
   integration with OpenAI services and comprehensive user experience management.
   1.2 Scope
   The system enables AI administrators to manage comprehensive conversation operations, dialogue
   processing workflows, and user interaction analytics while tracking conversation patterns and maintaining
   AI service quality standards. It supports administrators, AI researchers, prompt engineers, and users in
   managing conversations, optimizing AI interactions, and ensuring compliance with AI usage policies
   through role-based access control. The system will expose secured REST APIs, a web-based frontend with
   authentication, mobile applications, and comprehensive CRUD operations. Key functionalities include:
   AI administrator and user authentication system
   Role-based access control (Admin, AI Researcher, Prompt Engineer, Premium User, Free User)
   Complete CRUD operations for conversation and prompt management
   Advanced conversation threading and context preservation
   Real-time AI response optimization and analysis
   Multi-model AI integration and comparison features
   Conversation analytics and pattern recognition
   Prompt library management and sharing system
   Dashboard interfaces for different user roles
   Notification system for conversation insights and AI updates
   Reporting and analytics for conversation effectiveness and user engagement
   AI safety monitoring and content moderation system
   Security features including data validation and audit logging
   Comprehensive search and filtering capabilities across conversations
   Mobile application for seamless AI interaction and conversation management
   Integration with OpenAI APIs and other AI service providers
   1.3 Definitions, Acronyms, and Abbreviations
   API: Application Programming Interface
   REST: Representational State Transfer
   UI: User Interface
   SRS: Software Requirements Specification
   CORS: Cross-Origin Resource Sharing
   JPA: Java Persistence API
   JWT: JSON Web Token
   RBAC: Role-Based Access Control
   CRUD: Create, Read, Update, Delete
   AI: Artificial Intelligence
   ML: Machine Learning
   NLP: Natural Language Processing
   GPT: Generative Pre-trained Transformer
   LLM: Large Language Model
   RAG: Retrieval-Augmented Generation
   SDK: Software Development Kit
   OAuth: Open Authorization
   JSON: JavaScript Object Notation
   HTTP: Hypertext Transfer Protocol
   1.4 References
   IEEE Std 830-1998: IEEE Recommended Practice for Software Requirements Specifications
   Spring Boot Security Documentation
   React.js Documentation
   OpenAI API Documentation
   AI Ethics and Safety Guidelines
   Natural Language Processing Standards
   Conversational AI Best Practices
   1.5 Overview
   This document covers a high-level system overview, user roles, interface descriptions, and specific
   functional and non-functional requirements for the ChatGPT Conversation Management System with
   enhanced security, role-based features, and comprehensive AI conversation management and
   optimization capabilities.
2. Overall Description
   2.1 Product Perspective
   This is a standalone web and mobile application developed using Spring Boot for backend services with
   Spring Security, React.js for frontend interface with authentication, native mobile applications for AI
   interaction, and secured REST APIs for communication. The system uses JPA for database operations, JWT
   for authentication, integrates with OpenAI APIs and other AI services, and implements comprehensive
   role-based access control specifically designed for conversation management and AI interaction
   optimization operations.
   2.2 Product Functions
   AI administrator and user registration and secure authentication system
   Role-based dashboard interfaces for different user types
   Complete CRUD operations for conversation and prompt template management
   Advanced conversation threading and context management workflow system
   Real-time AI model integration and response optimization
   Conversation analytics and pattern recognition engine
   Prompt engineering tools and template library management
   Multi-model AI comparison and performance analysis
   Notification system for conversation insights and AI model updates
   Reporting and analytics for conversation effectiveness and user engagement metrics
   Advanced search and filtering across conversation history and prompts
   AI safety monitoring and automated content moderation capabilities
   Mobile application for seamless conversation access and AI interaction
   2.3 User Classes and Characteristics
   System Administrator: Full system access, user management, system configuration, and AI service
   oversight
   AI Researcher: Advanced analytics access, model performance analysis, conversation pattern
   research, and experimental feature testing
   Prompt Engineer: Prompt template creation, optimization workflows, A/B testing capabilities, and
   conversation effectiveness analysis
   Content Moderator: Safety monitoring, content review, policy enforcement, and user behavior
   analysis
   Premium User: Advanced conversation features, unlimited interactions, priority processing, and
   enhanced analytics access
   Free User: Basic conversation functionality, limited daily interactions, standard response times, and
   basic history access
   Developer: API access, integration capabilities, webhook management, and technical documentation
   access
   Guest User: Limited demo access, conversation previews, and registration encouragement features
   2.4 Operating Environment
   Server: Spring Boot 3.x with Spring Security (Java 17+)
   Database: JPA-compatible database with conversation and AI interaction tables
   Frontend: React.js with authentication components (port 8081)
   Mobile: Native iOS and Android applications with offline capabilities
   Backend: Spring Boot with security (port 8080)
   Authentication: JWT-based authentication with OAuth integration
   AI Integration: OpenAI API, Anthropic Claude API, and other LLM services
   Real-time Communication: WebSocket for live conversation features
   Testing: JUnit for backend, React Testing Library for frontend testing
   2.5 Design and Implementation Constraints
   RESTful API design with security features
   JWT-based authentication required for all protected operations
   Role-based access control implementation mandatory
   Comprehensive input validation and sanitization
   Conversation data storage and privacy compliance requirements
   Real-time AI interaction and response optimization mandatory
   Mobile-responsive design for seamless conversation access
   Integration with multiple AI service providers required
   AI safety monitoring and content moderation implementation
   High-performance conversation processing and context management
   2.6 User Documentation
   AI administrator registration and system management guides
   Role-specific user manuals
   User guide for conversation management and AI interaction
   Mobile application user guide
   Prompt engineering best practices documentation
   AI safety and ethical usage guidelines
   2.7 Assumptions and Dependencies
   Users have secure internet access and modern web browsers
   Integration with OpenAI and other AI service providers
   Real-time communication infrastructure for live conversations
   Mobile device compatibility for AI interaction
   Backup and recovery service availability
   Future integration with emerging AI technologies and models
3. Specific Requirements
   3.1 External Interfaces
   3.1.1 User Interfaces
   Landing/Home Page: AI conversation overview with featured conversations and quick start options
   User Registration: Account creation with AI usage preferences and role assignment
   Login/Authentication: Secure login with social media and AI service integration options
   Conversation Dashboard: Personal conversation management with threading and organization
   tools
   AI Chat Interface: Real-time conversation interface with multiple AI models and customization
   options
   Prompt Library: Template management for reusable prompts and conversation starters
   Admin Panel: User management, AI service configuration, and system oversight
   Analytics Dashboard: Conversation analytics, model performance, and user engagement metrics
   Mobile Application: Seamless AI conversation access with offline conversation history
   3.1.2 Hardware Interfaces
   Mobile device sensors for voice input and gesture controls
   Microphone access for voice-to-text conversation features
   Camera integration for image-based AI interactions
   Notification systems for conversation alerts and AI updates
   Bluetooth connectivity for hands-free conversation access
   3.1.3 Software Interfaces
   Secured REST API with JWT authentication
   OpenAI API integration for GPT models and conversation processing
   Anthropic Claude API for alternative AI model access
   Google Cloud AI services for additional NLP capabilities
   Social media platform integration for conversation sharing
   Cloud storage integration for conversation backup and synchronization
   3.1.4 Communication Interfaces
   HTTPS protocols with SSL/TLS encryption
   JSON data format with security headers
   WebSocket connections for real-time conversation features
   OAuth 2.0 authentication for third-party AI service integration
   Push notification services for mobile applications
   3.2 Functional Requirements
   User Authentication and Account Management
   FR1: Comprehensive User Registration and AI Preference System
   Description: The system shall provide a comprehensive user registration mechanism that captures
   essential user information, AI interaction preferences, validates credentials, and ensures compliance with
   AI usage access standards. This functionality serves as the foundation for establishing personalized AI
   experiences and maintaining access control throughout the platform.
   Detailed Requirements:
   The registration form shall capture complete user information including full name, email address, AI
   usage goals, preferred interaction styles, and conversation topics of interest
   User verification shall require email confirmation and optional AI service account linking for enhanced
   personalization
   AI preference setup shall include conversation style preferences, response length settings, model
   preferences, and topic specialization interests
   Platform access compliance shall validate user eligibility, age verification for AI interactions, and
   policy acknowledgment
   Account activation workflow shall include automated verification followed by personalized AI
   interaction tutorial
   expandImg

ChatGPT Conversation Management System

Problem Statement:

This project allows users to manage and interact with ChatGPT conversations efficiently. Users can create conversations with prompts, view past chats, filter them based on category (e.g., Coding, Education, General, Career), and sort them by creation time. The frontend is built with React.js and communicates with a Spring Boot backend API that handles chat data storage and retrieval logic. The primary goal is to help users manage ChatGPT conversations through an intuitive interface.

Key Features:

Conversation Management:

Add new conversations with details: prompt, response, category, timestamp

List all conversations added by the user

Delete a conversation by ID

Filtering & Sorting:

Filter conversations by category (Coding, Education, General, Career)

Sort conversations by timestamp (descending order, newest first)

User Interaction:

Input prompt via a form

View AI-generated responses

View a dynamic list of conversations with filtering/sorting options

Tech Stack:

Frontend: React.js (port 8081)

Backend: Spring Boot (port 8080)

Frontend Folder Structure:

Frontend Components:

Header Component:

Displays application title: “ChatGPT Conversation Manager”

Displays tagline: “Organize your AI chats efficiently”

ChatForm Component:

Functional React component with input fields:

prompt
category (dropdown: Coding, Education, General, Career)
Maintains internal state for form inputs

Calls backend API to add a conversation on submission

Calls parent onAdd prop function to refresh conversation list

Resets form after submission

ChatList Component:

Functional React component

Receives conversation list as prop

Displays conversation details in styled cards (Prompt + Response)

Supports delete functionality for conversations

App.js:

Root component maintaining state:

conversations (array)
filter (string: "all", "category")
Fetches conversation list on component mount and when filter changes

Renders:

Header
Filter/Sort dropdown
ChatForm (passing onAdd)
ChatList (passing conversations)

Frontend Service File: api.js

Exports functions for HTTP communication with backend:

addConversation(conversation) → POST [http://localhost:8080/api/chats/addConversation](http://localhost:8080/api/chats/addConversation)
getAllConversations() → GET [http://localhost:8080/api/chats/allConversations](http://localhost:8080/api/chats/allConversations)
getConversationsByCategory(category) → GET [http://localhost:8080/api/chats/byCategory?category={category}](http://localhost:8080/api/chats/byCategory?category={category})
getConversationsSortedByTime() → GET [http://localhost:8080/api/chats/sortedByTime](http://localhost:8080/api/chats/sortedByTime)
deleteConversation(id) → DELETE [http://localhost:8080/api/chats/{id}](http://localhost:8080/api/chats/{id})

Backend API Endpoints:

Create Conversation

URL: /api/chats/addConversation

Method: POST

Request Body:

{

"prompt": "Explain Java Streams",

"response": "Java Streams allow functional-style operations on collections...",

"category": "Coding",

"timestamp": "2025-09-04T18:30:00"

}

Response (200 OK): Returns created conversation object

Get All Conversations

URL: /api/chats/allConversations

Method: GET

Response (200 OK):

\[

{

```
"id": 1,

"prompt": "What is React?",

"response": "React is a JavaScript library for building UI...",

"category": "Education",

"timestamp": "2025-09-04T18:00:00"
```

}

]

Get Conversations by Category

URL: /api/chats/byCategory?category={category}

Method: GET

Description: Retrieves conversations based on category

Get Conversations Sorted by Time

URL: /api/chats/sortedByTime

Method: GET

Description: Retrieves all conversations sorted by timestamp (descending)

Delete Conversation

URL: /api/chats/{id}

Method: DELETE

Description: Deletes a conversation by ID

Backend Folder Structure:

﻿

API Documentation (Spring Boot):

Model: Conversation.java

Annotated with @Entity

Fields:
id (Long, Primary Key, Auto-generated)
prompt (String)
response (String)
category (String)
timestamp (LocalDateTime)

Repository: ConversationRepository.java

Extends JpaRepository\<Conversation, Long>

Custom methods:

findByCategory(String category)
findAllByOrderByTimestampDesc()

Service: ConversationService.java

Methods:

saveConversation(Conversation conversation)
getAllConversations()
getConversationsByCategory(String category)
getConversationsSortedByTime()
deleteConversation(Long id)

Controller: ConversationController.java

Base path: /api/chats

Methods:

@PostMapping("/addConversation") – Add conversation
@GetMapping("/allConversations") – Get all conversations
@GetMapping("/byCategory") – Get conversations by category
@GetMapping("/sortedByTime") – Get conversations sorted by time
@DeleteMapping("/{id}") – Delete conversation by ID

Sample Output:

Platform Instructions to run the application:

Backend:

Open the terminal and follow the steps below:

Navigate to the springapp directory using the terminal: cd springapp
To start/run the application: mvn spring-boot\:run

Frontend:

Open the terminal and follow the steps below:

Use cd reactapp command to navigate to the reactapp directory.
Use npm i command to install the node\_modules.
Use npm start command to start the application.
Note:

Application Properties and pom.xml: Do not modify the application.properties and pom.xml files. Modifying them may result in build failure and test case errors.
Naming Convention: Follow the specified naming convention for the folders, files, classes, and variables as shown in the provided image.
Click "PORT: 8081" to view the output.
Click "Run Test Case" button to run the test cases.
If any error persists while running the app, delete the node\_modules and reinstall them.

